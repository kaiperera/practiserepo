---
title: "chapter_3"
output: html_document
date: "2025-01-21"
---
#### Data Transformation
### Prerequisites
```{r}
library(tidyverse)
```
```{r}
library(nycflights13)
```
Knowing package helps find related functions so when need to be precise about which package function comes from: packagename::functionname()

###nycflights13
To explore the basic dplyr verbs, use nycflights13::flights:
```{r}
nycflights13::flights
```
flights is a tibble- dataframe for large data sets. Main difference between tibbles and data frames is way its printed- tibbles only print enough to fit on screen . If want to see everything:
```{r}
view(flights)
```
or
```{r}
glimpse(flights)
```
variable names followed by abbreviations- int= integer, dbl=double(real numbers), chr=character/strings, dttm=date-time. Important as operations you can perform on column depends a lot on type


###dplyr basics
primary dplyr verbs= functions: 1. 1st argument always a data frame 2.subsequent arguments usually describe which columns to operate on using variable names without quotes 3. output always a new data frame 
Pipe Operator %>%: Passes the output of one operation as input to the nex
Solving complex problesm requires combining multiple verbs- done using pipe ( |>)- takes object on left and passes it along to function on right eg) x |> f(y) is same as f(x,y). Easiest way to think of pipe is as "then". 
```{r}
flights |> 
  filter (dest == "IAH") |> 
  group_by(year,month,day) |>
  summarize(arr_delay = mean (arr_delay, na.rm = TRUE))
```
dplyr’s verbs are organized into four groups based on what they operate on: rows, columns, groups, or tables

###Rows
most important verbs operating on rows= filter()= changes which rows are present without changing order
arrange()= changes order of rows without changing which ones are present
Both functions only affect rows- columns left unchanged
distinct()= finds rows with unique values- can also optionally modify columns
## Filter
allows you to keep rows based on column value. First argument= dataframe. Second and subsequent arguments are conditions that must be true to keep row. Eg) could find all flights that departed more than 120 minutes late: 
```{r}
flights |> filter(dep_delay > 120)
```
As well as > (greater than), you can use >= (greater than or equal to), < (less than), <= (less than or equal to), == (equal to), and != (not equal to). You can also combine conditions with & or , to indicate “and” (check for both conditions) or with | to indicate “or” (check for either condition):
```{r}
# Flights that departed Jan 1
flights |> 
  filter(month == 1 & day==1)
```
```{r}
#Flights departed in Jan or Feb
flights |>
  filter (month==1 |month== 2)
```
shortcut for combining | and ==: %in%. It keeps rows where the variable equals one of the values on the right:
```{r}
# Shortcut- flights either jan or feb
flights |>
  filter(month %in% c(1,2))
```
When you run filter() dplyr executes the filtering operation, creating a new data frame, and then prints it. It doesn’t modify the existing flights dataset because dplyr functions never modify their inputs. To save the result, you need to use the assignment operator, <-:
```{r}
jan1 <- flights |>
  filter(month==1 & day==1)
```

## Arrange
changes order of rows based on value of columns- takes data frame and set of column names (or more complicated expressions) to order by.
If more than 1 column name provided, each additional column will be used to break ties in values of preceding columns. For example, the following code sorts by the departure time, which is spread over four columns. We get the earliest years first, then within a year, the earliest months:
```{r}
flights |>
  arrange(year, month, day, dep_time)
```
can use desc() on a column inside of arrange() to re-order the data frame based on that column in descending (big-to-small) order:
```{r}
flights |>
  arrange(desc(dep_delay))
#flights from most to least delayed
```
number of rows not changed- only arranging not filtering 
Pipe Operator %>%: Passes the output of one operation as input to the nex

##Distinct
finds all unique rows in a dataset- primarily operates on rows BUT you’ll want the distinct combination of some variables, so you can also optionally supply column names:
```{r}
#remove any duplicate rows
flights |>
  distinct()
```
Alternatively, if you want to keep other columns when filtering for unique rows, you can use the .keep_all = TRUE option.
```{r}
flights |>
  distinct(origin,dest, .keep_all = TRUE)
```
all of these distinct flights on Jan1- will find first occurrence of unique row in dataset and discard rest
If you want to find number of occurrences instead , swap distinct () for count()- with sort = TRUE argument, can arrange in descending order of number of occurrences:
```{r}
flights |>
  count(origin, dest, sort = TRUE)
```


### Exercises
1) In a single pipeline for each condition, find all flights that meet the condition:

    a) Had an arrival delay of two or more hours
```{r}
flights |>
  filter(arr_delay >= 120)
  
```
    
    b) Flew to Houston (IAH or HOU)
```{r}
flights |>
  filter(dest == "IAH" | dest == "HOU")
```
    
    c) Were operated by United, American, or Delta
```{r}
flights |>
  filter(carrier == "AA" | carrier == "DL"  | carrier == "UA")
```
    
    d) Departed in summer (July, August, and September)
```{r}
flights |>
  filter (month == 7 | month == 8 | month == 9)
```
   
    e) Arrived more than two hours late but didn’t leave late
```{r}
flights |>
  filter(arr_delay > 120 & dep_delay == 0 )
```
    
    f) Were delayed by at least an hour, but made up over 30 minutes in flight
```{r}
flights |>
  filter(dep_delay > 60 & air_time > 30)
```

2) Sort flights to find the flights with the longest departure delays. Find the flights that left earliest in the morning:- earliest flight at 06:41 on 9th Jan
```{r}
flights |>
    filter(dep_time <1200) %>% arrange(desc(dep_delay))
 

```

3) Sort flights to find the fastest flights. 
```{r}
flights |>
  arrange(air_time)
```

4) Was there a flight on every day of 2013?
```{r}
flights |>
  
```

5) Which flights traveled the farthest distance? Which traveled the least distance?
```{r}
flights |>
  arrange(desc(distance))
```
furthest distance = 4983, least distance= 2586


6) Does it matter what order you used filter() and arrange() if you’re using both? Why/why not? Think about the results and how much work the functions would have to do: better to use filter first as narrows down rows needed to arrange 


### Columns
4 important verbs affecting columns without changing rows:
  1) mutate()= creates new columns derived from existing columns
  2) select()= changes which columns are present
  3) rename()
  4) relocate()= changes columns position
  
##Mutate
```{r}
flights |>
  mutate(gain = dep_delay - arr_delay,
    speed = distance /air_time *60)
```
By default, mutate() adds new columns on the right-hand side of your dataset, which makes it difficult to see what’s happening here. We can use the .before argument to instead add the variables to the left-hand side:
```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .before = 1
  )
```
. indicates that .before is an argument to the function not name of new variable- can also use .after to add after a variable, and in both .before and .after you can use the variable name instead of a position:
```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .after = day
  )
```
Can control which variables are kept w .keep argument . Used argument specifies that we only keep columns involved in/ created in mutate step:
```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    hours = air_time / 60,
    gain_per_hour = gain / hours,
    .keep = "used"
  )
```
new variables wont be stored in data frame as havent assigned results of above back to flights. Rather than rewriting original data, better to create new object named informatively to indicate content

## Select
allows you to rapidly zoom in on useful subset using operations based on names of the variables 
1) select columns by name:
```{r}
flights |> 
  select(year, month, day)
```
2) select all columns betwwen year and day (inclusive):
```{r}
flights |> 
  select(year:day)
```
3) Select all columns except those from year to day (inclusive):
```{r}
flights |> 
  select(!year:day)
```
4) Select all columns that are characters:
```{r}
flights |> 
  select(where(is.character))
```
Several helper functions:

    starts_with("abc"): matches names that begin with “abc”.
    ends_with("xyz"): matches names that end with “xyz”.
    contains("ijk"): matches names that contain “ijk”.
    num_range("x", 1:3): matches x1, x2 and x3.
can rename variables as you select() them by using =.:
```{r}
flights |> 
  select(tail_num = tailnum)
```

##Rename
```{r}
flights |> 
  rename(tail_num = tailnum)
```
If you have a bunch of inconsistently named columns, janitor::clean_names()  provides some useful automated cleaning

## Relocate
Use relocate() to move variables around.  might want to collect related variables together or move important variables to the front. By default relocate() moves variables to the front
```{r}
flights |> 
  relocate(time_hour, air_time)
```
can also specify where to put them using the .before and .after argument:
```{r}
flights |> 
  relocate(year:dep_time, .after = time_hour)
flights |> 
  relocate(starts_with("arr"), .before = dep_time)
```

